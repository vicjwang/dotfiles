---
description: 
globs: 
alwaysApply: true
---
---
description: Standardizes the handling of date-only values (YYYY-MM-DD) by assuming they represent dates in US Eastern Time (ET).
globs: **/*.{ts,tsx,js,jsx} # Apply to TypeScript/JavaScript files
alwaysApply: false
---
# Handling Date-Only Values (YYYY-MM-DD) Assuming US Eastern Time

This rule specifies that all date-only strings (e.g., `YYYY-MM-DD`) encountered in the codebase should be interpreted as representing the calendar date in the **US Eastern Timezone** (specifically `America/New_York`). This prevents ambiguity and ensures consistent date interpretation, regardless of the server or user's local timezone.

## The Problem

Without a clear convention, a date string like `2024-11-04` could be interpreted differently depending on the context:
- As UTC midnight (`2024-11-04T00:00:00Z`)
- As local midnight (`2024-11-04T00:00:00` in the executing environment's timezone)

This ambiguity leads to off-by-one errors when converting between timezones or performing date calculations, especially around Daylight Saving Time transitions.

## Guideline

1.  **Assume Eastern Time (ET):** When parsing a `YYYY-MM-DD` string, treat it as midnight (`00:00:00`) on that date *in the `America/New_York` timezone*.
2.  **Use Timezone-Aware Libraries:** Employ libraries like `date-fns-tz`, `dayjs` (with timezone plugins), or potentially `Temporal` (when available) that explicitly handle timezone conversions.
3.  **Convert to UTC for Storage/Calculations (Recommended):** While the *interpretation* is ET, it's often best practice to convert the ET date/time instant to a UTC timestamp immediately after parsing. Perform calculations and store dates in UTC to avoid complexities with DST or future timezone rule changes.
4.  **Format Explicitly:** When displaying the date or formatting it back to a string, explicitly specify the target timezone if it's different from UTC (e.g., back to `America/New_York` for display if needed, or keep as `YYYY-MM-DD` based on UTC).
5.  **Canonical Timezone ID:** Always use the IANA timezone identifier `America/New_York` for US Eastern Time, rather than abbreviations like `EST` or `EDT`, which are ambiguous.

## Examples

Let's assume we have the date string `2024-03-10` (the day DST starts in the US in 2024).

❌ **Bad (Ambiguous Parsing):**

```typescript
// This relies on the system's local timezone, which is unreliable.
const dateString = '2024-03-10';
const ambiguousDate = new Date(dateString); // Might be UTC, might be local midnight.

// Calculations are unpredictable.
ambiguousDate.setDate(ambiguousDate.getDate() + 1);
console.log(ambiguousDate.toISOString()); // Output varies based on where the code runs.
```

✅ **Good (Using `date-fns-tz`):**

```typescript
import { format } from 'date-fns';
import { zonedTimeToUtc, utcToZonedTime, formatInTimeZone } from 'date-fns-tz';
import { addDays } from 'date-fns'; // Use functions from date-fns

const dateString = '2024-03-10';
const easternTimeZone = 'America/New_York';

// 1. Parse the string assuming it's midnight in ET
// zonedTimeToUtc gives the UTC Date object equivalent to '2024-03-10 00:00:00' in America/New_York
const dateInUTC = zonedTimeToUtc(dateString, easternTimeZone);
// dateInUTC is now a standard JavaScript Date object representing the correct instant in time (UTC).
// For '2024-03-10', this is 2024-03-10T05:00:00Z (before DST shift)

// 2. Perform calculations (best done on the reliable Date/UTC object)
const nextDayUTC = addDays(dateInUTC, 1); // Add 1 day reliably

// 3. Format back to YYYY-MM-DD
// Option A: Format based on the UTC date (simple, represents the calendar date after calculation)
const formattedUTCDate = format(nextDayUTC, 'yyyy-MM-dd', { timeZone: 'UTC' });
console.log(formattedUTCDate); // Output: '2024-03-11'

// Option B: Format back into the ET timezone perspective
// Note: Requires careful thought about what 'YYYY-MM-DD' means after calculation.
// Usually, formatting the UTC date directly is less ambiguous for date-only strings.
const formattedETDate = formatInTimeZone(nextDayUTC, easternTimeZone, 'yyyy-MM-dd');
console.log(formattedETDate); // Output: '2024-03-11' (In this case, it matches UTC date part)

// Example showing the UTC instant:
console.log(dateInUTC.toISOString()); // -> 2024-03-10T05:00:00.000Z
console.log(nextDayUTC.toISOString()); // -> 2024-03-11T05:00:00.000Z
```

## Rationale

By defining a standard interpretation timezone (`America/New_York`) for all date-only strings, we eliminate ambiguity. Converting to UTC for internal representation provides a robust way to handle calculations and storage, free from DST complexities. This ensures that `YYYY-MM-DD` values consistently represent the intended day in the business's primary timezone (ET).